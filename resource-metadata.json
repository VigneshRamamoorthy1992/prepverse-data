{
  "path": "resources",
  "name": "resources",
  "children": [
    {
      "path": "resources/Beginner",
      "name": "Beginner",
      "children": [
        {
          "path": "resources/Beginner/Arrays",
          "name": "Arrays",
          "children": [
            {
              "path": "resources/Beginner/Arrays/2_sum.js",
              "name": "2_sum.js",
              "docs": "\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n",
              "solution": "\nfunction twoSum(arr, target) {\n  let map = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let pair = target - arr[i];\n    if (pair in map) {\n      return [map[pair], i];\n    } else {\n      map[arr[i]] = i;\n    }\n    console.log(map);\n  }\n\n  return [];\n}\n\nconsole.log(twoSum([2, 7, 11, 15], 26));\n\n// using sliding window\nvar twoSum = function (nums, target) {\n  let left = 0;\n  let right = 0;\n\n  let currentSum = 0;\n\n  for (let num of nums) {\n    currentSum += num;\n\n    while (currentSum > target) {\n      currentSum -= nums[left];\n      left += 1;\n    }\n    if (currentSum === target) {\n      return [left, right];\n    }\n    right += 1;\n  }\n  return [];\n};\n\nconsole.log(twoSum([2, 7, 11, 15], 7));\n",
              "tags": ["Amazon", " Microsoft"]
            },
            {
              "path": "resources/Beginner/Arrays/3_Sum.js",
              "name": "3_Sum.js",
              "docs": "\n\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n<pre>\n<code>\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExample 2:\n\nInput: nums = []\nOutput: []\nExample 3:\n\nInput: nums = [0]\nOutput: []\n \n\nConstraints:\n\n0 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n<code>\n<pre>\n\n\n",
              "solution": "\nfunction threeSum(nums, target) {\n  const results = [];\n  if (nums.length < 3) return results;\n\n  nums = nums.sort((a, b) => a - b);\n\n  // let target = 0\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (nums[i] > target) break;\n\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n    let j = i + 1;\n\n    let k = nums.length - 1;\n\n    while (j < k) {\n      let sum = nums[i] + nums[j] + nums[k];\n\n      if (sum === target) {\n        results.push([nums[i], nums[j], nums[k]]);\n\n        while (nums[j] === nums[j + 1]) j++;\n        while (nums[k] === nums[k - 1]) k--;\n\n        j++;\n        k--;\n      } else if (sum < target) {\n        j++;\n      } else {\n        k--;\n      }\n    }\n  }\n\n  return results;\n}\n\n// console.log(threeSum([-1,0,1,2,-1,-4]));\n\nconsole.log(threeSum([1, 7, 2, 5, 6, 2, 0], 8));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/all_required_substring_length.js",
              "name": "all_required_substring_length.js",
              "docs": "\n\n    given a string \"aabbbc\" find all the required lengths of a string aa bbb c\n    max length of consequtive string is 3 so required char for others is 2 return 3\n \n\n",
              "solution": "\nfunction sonultionStr(S) {\n  let chars = S.split(\"\");\n\n  let currentChar = chars[0];\n  let currentString = \"\";\n\n  let arr = [];\n  for (let char of chars) {\n    if (char === currentChar) {\n      currentString += char;\n    } else {\n      arr.push([currentString, currentString.length]);\n      currentString = char;\n      currentChar = char;\n    }\n  }\n  arr.push([currentString, currentString.length]);\n  let maxLength = findMaxLength(arr);\n  return findCharLengthRequired(arr, maxLength);\n}\n\nfunction findCharLengthRequired(arr, maxLength) {\n  let total = 0;\n  for (let data of arr) {\n    let [_, count] = data;\n    total += maxLength - count;\n  }\n  return total;\n}\n\nfunction findMaxLength(arrs) {\n  let maxLength = 0;\n  for (let arr of arrs) {\n    let [_, count] = arr;\n    if (count > maxLength) {\n      maxLength = count;\n    }\n  }\n  return maxLength;\n}\nconsole.log(sonultionStr(\"aabbbcc\"));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/container_with_most_water.js",
              "name": "container_with_most_water.js",
              "docs": "\n\nhttps://leetcode.com/problems/container-with-most-water/\n\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\n\n\nExample 1:\n\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\n",
              "solution": "\n\nfunction containerWithMostWater(arr) {\n  let maxWater = 0;\n  l = 0;\n  r = arr.length - 1;\n  while (l < r) {\n    maxWater = Math.max(maxWater, Math.min(arr[l], arr[r]) * (r - l));\n    if (arr[l] < arr[r]) {\n      l++;\n    } else {\n      r--;\n    }\n  }\n\n  return maxWater;\n}\n\nconsole.log(containerWithMostWater([1, 8, 6, 2, 5, 4, 8, 3, 7]));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/find_secret_word.js",
              "name": "find_secret_word.js",
              "docs": "\n\nhttps://leetcode.com/problems/guess-the-word/\n\nThis is an interactive problem.\n\nYou are given an array of unique strings wordlist where wordlist[i] is 6 letters long, and one word in this list is chosen as secret.\n\nYou may call Master.guess(word) to guess a word. The guessed word should have type string and must be from the original list with 6 lowercase letters.\n\nThis function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word. Also, if your guess is not in the given wordlist, it will return -1 instead.\n\nFor each test case, you have exactly 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or fewer calls to Master.guess and at least one of these guesses was secret, then you pass the test case.\n\n\n\nExample 1:\n\nInput: secret = \"acckzz\", wordlist = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], numguesses = 10\nOutput: You guessed the secret word correctly.\nExplanation:\nmaster.guess(\"aaaaaa\") returns -1, because \"aaaaaa\" is not in wordlist.\nmaster.guess(\"acckzz\") returns 6, because \"acckzz\" is secret and has all 6 matches.\nmaster.guess(\"ccbazz\") returns 3, because \"ccbazz\" has 3 matches.\nmaster.guess(\"eiowzz\") returns 2, because \"eiowzz\" has 2 matches.\nmaster.guess(\"abcczz\") returns 4, because \"abcczz\" has 4 matches.\nWe made 5 calls to master.guess and one of them was the secret, so we pass the test case.\nExample 2:\n\nInput: secret = \"hamada\", wordlist = [\"hamada\",\"khaled\"], numguesses = 10\nOutput: You guessed the secret word correctly.\n\n\nConstraints:\n\n1 <= wordlist.length <= 100\nwordlist[i].length == 6\nwordlist[i] consist of lowercase English letters.\nAll the strings of wordlist are unique.\nsecret exists in wordlist.\nnumguesses == 10\n\n\n// guess word console.log(arr)\n[\n  [\n    2, 0, 1, 0, 1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0\n  ],\n  [\n    0, 1, 2, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0\n  ],\n  [\n    0, 1, 2, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 1, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0\n  ],\n  [\n    1, 0, 1, 0, 0, 0, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 1, 0,\n    0, 0\n  ],\n  [\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 4\n  ],\n  [\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 4\n  ]\n]\nacckzz  :  15\n\n\n",
              "solution": "\nvar findSecretWord = function (wordlist, master) {\n  while (wordlist.length > 0) {\n    let guess_word = findGuessWord(wordlist);\n    let matchCount = master.guess(guess_word);\n\n    if (matchCount === 6) return guess_word;\n\n    console.log(\"bw: \", guess_word, \" : \", matchCount);\n    wordlist = filterWord(wordlist, guess_word, matchCount);\n  }\n};\n\nfunction findGuessWord(wordlist) {\n  let arr = [...Array(6)].map((e) => Array(26).fill(0));\n\n  for (let i = 0; i < wordlist.length; i++) {\n    for (let j = 0; j < wordlist[i].length; j++) {\n      arr[j][wordlist[i][j].charCodeAt(0) - \"a\".charCodeAt(0)] += 1;\n    }\n  }\n  console.log(arr);\n\n  let best_word = \"\";\n  let best_count = 0;\n\n  for (let i = 0; i < wordlist.length; i++) {\n    let curr_count = 0;\n    for (let j = 0; j < wordlist[i].length; j++) {\n      curr_count += arr[j][wordlist[i][j].charCodeAt(0) - \"a\".charCodeAt(0)];\n    }\n    if (curr_count > best_count) {\n      best_count = curr_count;\n      best_word = wordlist[i];\n    }\n  }\n  console.log(best_word, \" : \", best_count);\n  return best_word;\n}\n\nfunction filterWord(wordlist, guess_word, matchCount) {\n  // if(matchCount = -1) return wordlist.filter(f=> f!== guess_word);\n  let x = wordlist.filter((f) => {\n    return compareWord(f, guess_word) === matchCount;\n  });\n\n  console.log(x);\n\n  return x;\n}\n\nfunction compareWord(word, guess_word) {\n  let counter = 0;\n  for (let i = 0; i < 6; i++) {\n    if (word[i] === guess_word[i]) counter++;\n  }\n\n  return counter;\n}\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/first_unique_char_in_a_string.js",
              "name": "first_unique_char_in_a_string.js",
              "docs": "\n\n\nhttps://leetcode.com/problems/first-unique-character-in-a-string/\n\nGiven a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n\n\nExample 1:\n\nInput: s = \"leetcode\"\nOutput: 0\nExample 2:\n\nInput: s = \"loveleetcode\"\nOutput: 2\nExample 3:\n\nInput: s = \"aabb\"\nOutput: -1\n\n\nConstraints:\n\n1 <= s.length <= 105\ns consists of only lowercase English letters.\n\n\n\n",
              "solution": "\nlet firstUniqChar = function (s) {\n  let map = new Map();\n  for (let x of s) {\n    if (map.has(x)) {\n      map.set(x, map.get(x) + 1);\n    } else {\n      map.set(x, 0);\n    }\n  }\n  console.log(map, \"map\");\n  for (let [k, v] of map) {\n    if (v === 0) {\n      let val = s.indexOf(k);\n      return val;\n    }\n  }\n};\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/group_anagram.js",
              "name": "group_anagram.js",
              "docs": "\n Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n \n\nExample 1:\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\n\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\n\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n \n\nConstraints:\n\n1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters. \n\n",
              "solution": "\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Arrays/integer_to_roman.js",
              "name": "integer_to_roman.js",
              "docs": "\n\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral.\n\n\n\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= num <= 3999\n\n\n",
              "solution": "\nfunction integerToRoman(num) {\n  let romanList = {\n    M: 1000,\n    CM: 900,\n    D: 500,\n    CD: 400,\n    C: 100,\n    XC: 90,\n    L: 50,\n    XL: 40,\n    X: 10,\n    IX: 9,\n    V: 5,\n    IV: 4,\n    I: 1,\n  };\n\n  let result = \"\";\n\n  for (let item in romanList) {\n    let numberOfTimes = num / romanList[item];\n    if (numberOfTimes !== 0) {\n      result += item.repeat(numberOfTimes);\n    }\n    num %= romanList[item];\n  }\n\n  return result;\n}\n\nconsole.log(integerToRoman(1994));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/integer_to_word.js",
              "name": "integer_to_word.js",
              "docs": "\n Given an Integer convert it into a word \n\n",
              "solution": "\nvar numberToWords = function (num) {\n  if (num === 0) {\n    return \"Zero\";\n  }\n\n  if (num <= 20) {\n    return translations.get(num);\n  }\n\n  let result = [];\n\n  for (let [value, translation] of translations) {\n    const times = Math.floor(num / value);\n\n    if (times === 0) {\n      continue;\n    }\n\n    num -= times * value;\n\n    if (times === 1 && value >= 100) {\n      result.push(\"One\", translation);\n      continue;\n    }\n\n    if (times === 1) {\n      result.push(translation);\n      continue;\n    }\n\n    result.push(numberToWords(times), translation);\n  }\n\n  return result.join(\" \");\n};\n\nconst translations = new Map([\n  [1000000000, \"Billion\"],\n  [1000000, \"Million\"],\n  [1000, \"Thousand\"],\n  [100, \"Hundred\"],\n  [90, \"Ninety\"],\n  [80, \"Eighty\"],\n  [70, \"Seventy\"],\n  [60, \"Sixty\"],\n  [50, \"Fifty\"],\n  [40, \"Forty\"],\n  [30, \"Thirty\"],\n  [20, \"Twenty\"],\n  [19, \"Nineteen\"],\n  [18, \"Eighteen\"],\n  [17, \"Seventeen\"],\n  [16, \"Sixteen\"],\n  [15, \"Fifteen\"],\n  [14, \"Fourteen\"],\n  [13, \"Thirteen\"],\n  [12, \"Twelve\"],\n  [11, \"Eleven\"],\n  [10, \"Ten\"],\n  [9, \"Nine\"],\n  [8, \"Eight\"],\n  [7, \"Seven\"],\n  [6, \"Six\"],\n  [5, \"Five\"],\n  [4, \"Four\"],\n  [3, \"Three\"],\n  [2, \"Two\"],\n  [1, \"One\"],\n]);\n\nconsole.log(numberToWords(105992));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/kth_closest_point_to_origin.js",
              "name": "kth_closest_point_to_origin.js",
              "docs": "\n\n\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n\n\n\nExample 1:\n\n\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\nExample 2:\n\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n\n\nConstraints:\n\n1 <= k <= points.length <= 104\n-104 < xi, yi < 104\n\n\n\n",
              "solution": "\nvar kClosest = function (points, k) {\n  const unordered = points.map(([x, y], index) => {\n    return [index, Math.sqrt(x * x + y * y)]; // as x2, y2 is origin (0,0)\n  });\n  const ordered = unordered.sort((a, b) => a[1] - b[1]);\n  return ordered.slice(0, k).map(([index]) => points[index]);\n};\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/longest_sub_string.js",
              "name": "longest_sub_string.js",
              "docs": "\n\nGiven a string s, find the length of the longest substring without repeating characters.\n\n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n\n",
              "solution": "\nfunction logestSubstr(s) {\n  let begin = 0;\n  let map = {};\n  let max = 0;\n\n  for (let end = 0; end < s.length; end++) {\n    if (map[s[end]] !== undefined && map[s[end]] >= begin) {\n      begin = map[s[end]] + 1;\n    }\n    map[s[end]] = end;\n    max = Math.max(max, end - begin + 1);\n  }\n  return max;\n}\n\n// sliding window\nfunction longestSubStr(s) {\n  let left = 0;\n  let map = {};\n\n  return s.split(\"\").reduce((max, val, ind) => {\n    left = map[val] >= left ? map[val] + 1 : left;\n\n    map[val] = ind;\n\n    return Math.max(max, ind - left + 1);\n  }, 0);\n}\n\nconsole.log(longestSubStr(\"abcabcbb\"));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/median_of_2_Arrays.js",
              "name": "median_of_2_Arrays.js",
              "docs": "\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n\n\n",
              "solution": "\nfunction medianOf2Arr(arr1, arr2) {\n  arr1 = arr1.concat(arr2).sort((a, b) => a - b);\n  console.log(arr1);\n\n  let len = arr1.length;\n\n  if (len % 2 === 1) return arr1[Math.floor(len / 2)];\n  else return (arr1[len / 2 - 1] + arr1[len / 2]) / 2;\n}\n\nconsole.log(medianOf2Arr([1, 4, 7, 9], [2, 5, 8, 10]));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/minimum_window_substring.js",
              "name": "minimum_window_substring.js",
              "docs": "\n\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n\nA substring is a contiguous sequence of characters within the string.\n\n\n\nExample 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n <= 105\ns and t consist of uppercase and lowercase English letters.\n\n\nFollow up: Could you find an algorithm that runs in O(m + n) time?\n\n\n",
              "solution": "\nfunction minWindowSubstring(s, t) {\n  let result = \"\";\n  let minLen = Number.MAX_SAFE_INTEGER;\n  const map = new Map();\n  let counter = t.length;\n  let begin = 0;\n  let end = 0;\n\n  for (const character of t) {\n    if (map.has(character)) {\n      map.set(character, map.get(character) + 1);\n    } else {\n      map.set(character, 1);\n    }\n  }\n\n  while (end <= s.length) {\n    if (counter === 0) {\n      const beginChar = s[begin];\n      if (end - begin < minLen) {\n        minLen = end - begin;\n        result = s.substring(begin, end);\n      }\n      if (map.has(beginChar)) {\n        map.set(beginChar, map.get(beginChar) + 1);\n        if (map.get(beginChar) > 0) {\n          counter++;\n        }\n      }\n      begin++;\n    } else {\n      const endChar = s[end];\n      if (map.has(endChar)) {\n        map.set(endChar, map.get(endChar) - 1);\n        if (map.get(endChar) >= 0) {\n          counter--;\n        }\n      }\n      end++;\n    }\n  }\n\n  return result;\n}\n\nconsole.log(minWindowSubstring(\"ADOBECODEBANC\", \"ABC\"));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/most_common_word.js",
              "name": "most_common_word.js",
              "docs": "\n\nGiven a string paragraph and a string array of the banned words `banned`, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\n\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n\nExample 1:\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation:\n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.\nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"),\nand that \"hit\" isn't the answer even though it occurs more because it is banned.\nExample 2:\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\n\n\nConstraints:\n\n1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters\n\n\n\n",
              "solution": "\nvar mostCommonWord = function (paragraph, banned) {\n  //Split the paragraph into an array of words in lowercase\n  const words = paragraph.toLowerCase().split(/\\W/);\n  console.log(\"dasd>>> \", words);\n  //Create a map to act as histogram of words\n  const mp = Object.create(null);\n  //Filter out empty strings and make the histogram\n  words.filter((x) => x).map((x) => (mp[x] = x in mp ? mp[x] + 1 : 1));\n  //Rather than deleting banned words, just set its value to a negative number\n  banned.map((x) => (mp[x] = -1));\n  console.log(\"dasd: \", mp);\n  //Return the word with the highest count in the histogram\n  return Object.keys(mp).reduce((a, b) => (mp[a] > mp[b] ? a : b));\n};\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/non_overlaping_subarray.js",
              "name": "non_overlaping_subarray.js",
              "docs": "\n\n given an array build non overlaping sub array\n \n\n",
              "solution": "\n\nfunction maxNonOverLapping(A) {\n  let ends = [...new Array(A.length + 1)].map((e) => 0);\n  let indexes = new Map();\n  indexes.set(0, 0);\n  let sum = 0;\n  let max = 0;\n  for (let i = 0; i < A.length; i++) {\n    sum += A[i];\n    ends[i + 1] = ends[i];\n    if (indexes.has(sum)) {\n      ends[i + 1] = Math.max(ends[i + 1], ends[indexes.get(sum)] + 1);\n    }\n    indexes.set(sum, i + 1);\n  }\n\n  console.log(ends);\n  return ends[A.length];\n}\n\nlet x = maxNonOverLapping([10, 1, 3, 1, 2, 2, 1, 0, 4]);\nconsole.log(x);\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/product_of_array_except_self.js",
              "name": "product_of_array_except_self.js",
              "docs": "\n\nGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n\n\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\n\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\nConstraints:\n\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\n\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)\n\n\n\n",
              "solution": "\n\nfunction productOfArrayExceptSelf(nums) {\n  let zeroCount = 0;\n  let prod = nums.reduce((p, v, i) => {\n    if (v === 0) zeroCount += 1;\n    return p * v;\n  }, 1);\n  console.log(\"asdas: \", prod);\n  let noZeroProd = 0;\n  if (prod === 0 && zeroCount === 1) {\n    noZeroProd = nums.reduce((p, v, i) => {\n      if (v != 0) {\n        return p * v;\n      }\n      return p;\n    }, 1);\n  }\n\n  nums = nums.map((e) => {\n    if (e === 0) {\n      return noZeroProd;\n    }\n    return prod / e;\n  });\n  return nums;\n}\n\nconsole.log(productOfArrayExceptSelf([-1, 1, 0, -3, 3]));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/reorder_data_logs.js",
              "name": "reorder_data_logs.js",
              "docs": "\n\nYou are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\n\nThere are two types of logs:\n\nLetter-logs: All words (except the identifier) consist of lowercase English letters.\nDigit-logs: All words (except the identifier) consist of digits.\nReorder these logs so that:\n\nThe letter-logs come before all digit-logs.\nThe letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.\nThe digit-logs maintain their relative ordering.\nReturn the final order of the logs.\n\n\n\nExample 1:\n\nInput: logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\nOutput: [\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\nExplanation:\nThe letter-log contents are all different, so their ordering is \"art can\", \"art zero\", \"own kit dig\".\nThe digit-logs have a relative order of \"dig1 8 1 5 1\", \"dig2 3 6\".\nExample 2:\n\nInput: logs = [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\nOutput: [\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n\n\nConstraints:\n\n1 <= logs.length <= 100\n3 <= logs[i].length <= 100\nAll the tokens of logs[i] are separated by a single space.\nlogs[i] is guaranteed to have an identifier and at least one word after the identifier.\n\n\n\n",
              "solution": "\n\nvar reorderLogFiles = function (logs) {\n  const letterLogs = [];\n  const digitLogs = [];\n  logs.forEach((log) => {\n    if (/ \\d/.test(log)) {\n      digitLogs.push(log);\n    } else {\n      letterLogs.push(log);\n    }\n  });\n\n  console.log(\"Digits : \", digitLogs);\n  console.log(\"leter : \", letterLogs);\n  letterLogs.sort((a, b) => {\n    const aBody = a.slice(a.indexOf(\" \") + 1);\n    const bBody = b.slice(b.indexOf(\" \") + 1);\n    const c = aBody.localeCompare(bBody);\n    if (c) return c;\n    return a.localeCompare(b);\n  });\n  return [...letterLogs, ...digitLogs];\n};\n\nreorderLogFiles([\n  \"dig1 8 1 5 1\",\n  \"let1 art can\",\n  \"dig2 3 6\",\n  \"let2 own kit dig\",\n  \"let3 art zero\",\n]);\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/roman_to_integer.js",
              "name": "roman_to_integer.js",
              "docs": "\n\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n\n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n\n\n\n",
              "solution": "\n\nfunction convertRomanToInteger(romanNum) {\n  let romanList = {\n    M: 1000,\n    D: 500,\n    C: 100,\n    L: 50,\n    X: 10,\n    V: 5,\n    I: 1,\n  };\n\n  let result = 0;\n\n  for (let i = 0; i < romanNum.length; i++) {\n    if (i > 0 && romanList[romanNum[i]] > romanList[romanNum[i - 1]]) {\n      result -= 2 * romanList[romanNum[i - 1]];\n    }\n\n    result += romanList[romanNum[i]];\n    console.log(\"RR >> \", result);\n  }\n  return result;\n}\n\nconsole.log(convertRomanToInteger(\"MCMXCIV\"));\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/rotate_image.js",
              "name": "rotate_image.js",
              "docs": "\n\nYou are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000\n\n\n\n",
              "solution": "\n\nfunction rotateImage(matrix) {\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = i; j < matrix[0].length; j++) {\n      let temp = matrix[i][j];\n      matrix[i][j] = matrix[j][i];\n      matrix[j][i] = temp;\n    }\n  }\n\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[0].length / 2; j++) {\n      let temp = matrix[i][j];\n      matrix[i][j] = matrix[i][matrix[0].length - j - 1];\n      matrix[i][matrix[0].length - j - 1] = temp;\n    }\n  }\n  return matrix;\n}\n\nconsole.log(\n  rotateImage([\n    [5, 1, 9, 11],\n    [2, 4, 8, 10],\n    [13, 3, 6, 7],\n    [15, 14, 12, 16],\n  ])\n);\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/set_matrix_zero.js",
              "name": "set_matrix_zero.js",
              "docs": "\n\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's, and return the matrix.\n\nYou must do it in place.\n\n\n\nExample 1:\n\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\nExample 2:\n\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1\n\n\nFollow up:\n\nA straightforward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution? \n\n",
              "solution": "\n\nvar setZeroes = function (matrix) {\n  var track = [];\n\n  // find zeros\n  for (var i = 0; i < matrix.length; i++) {\n    for (var j = 0; j < matrix[0].length; j++) {\n      if (matrix[i][j] === 0) track.push([i, j]);\n    }\n  }\n\n  for (var i = 0; i < track.length; i++) {\n    var [x, y] = track[i];\n\n    // update row\n    for (var j = 0; j < matrix[0].length; j++) {\n      matrix[x][j] = 0;\n    }\n\n    // udpate column\n    for (var j = 0; j < matrix.length; j++) {\n      matrix[j][y] = 0;\n    }\n  }\n};\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Arrays/simple_calculator_2.js",
              "name": "simple_calculator_2.js",
              "docs": "\n\nGiven a string s which represents an expression, evaluate this expression and return its value.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n\n\nExample 1:\n\nInput: s = \"3+2*2\"\nOutput: 7\nExample 2:\n\nInput: s = \" 3/2 \"\nOutput: 1\nExample 3:\n\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n\n\nConstraints:\n\n1 <= s.length <= 3 * 105\ns consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\ns represents a valid expression.\nAll the integers in the expression are non-negative integers in the range [0, 231 - 1].\nThe answer is guaranteed to fit in a 32-bit integer.\n\n\n\n",
              "solution": "\n\nvar calculate = function (s) {\n  let stack = [];\n  let num = \"\";\n  let sign = null;\n  // we loop till the full length of the array to account for last sign\n  for (let i = 0; i <= s.length; i++) {\n    const curr = s[i];\n    //handle space\n    if (curr === \" \") continue;\n    //if char is a number\n    if (!isNaN(curr)) num += curr;\n\n    console.log(\"1:: \", num);\n    //if we have a  sign + - / *\n    if (isNaN(curr)) {\n      // /\\D/.test()\n      num = Number(num);\n      console.log(\"curr: \", curr);\n      switch (sign) {\n        case \"+\":\n        case null:\n          //we push the initial number into the stack\n          stack.push(num);\n          break;\n        case \"-\":\n          //we push any values after the subtraction sign as negative\n          stack.push(-num);\n          break;\n        case \"*\":\n          //we pop the stack then multiply and push back\n          stack.push(stack.pop() * num);\n          break;\n        case \"/\":\n          //we pop the stack then devide and push back\n          stack.push(parseInt(stack.pop() / num, 10));\n          break;\n      }\n\n      console.log(stack);\n      // sign becomes current sign\n      sign = curr;\n      // we reset num\n      num = \"\";\n    }\n  }\n  //we reduce the array adding positive and negative numbers\n  return stack.reduce((a, b) => {\n    return a + b;\n  }, 0);\n};\n\ncalculate(\"33-2*2/2\");\n\n2 + 6 * 3 + 5 - ((3 * 14) / 7 + 2) * 5 + 3;\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/spiral_matrix.js",
              "name": "spiral_matrix.js",
              "solution": "\n\n/*\nGiven an m x n matrix, return all elements of the matrix in spiral order.\n\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\nExample 2:\n\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 10\n-100 <= matrix[i][j] <= 100 */\n\nvar spiralOrder = function (matrix) {\n  const res = [];\n  while (matrix.length) {\n    const first = matrix.shift();\n    res.push(...first);\n    for (const m of matrix) {\n      let val = m.pop();\n      if (val) res.push(val);\n      m.reverse();\n    }\n    matrix.reverse();\n  }\n  return res;\n};\n\nconsole.log(\n  spiralOrder([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n  ])\n);\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Arrays/trapping_rain_water.js",
              "name": "trapping_rain_water.js",
              "docs": "\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nExample 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\n \n\n",
              "solution": "\n\nvar trap = function (height) {\n  let left = [];\n  let leftMax = 0;\n\n  for (let i = 0; i < height.length; i++) {\n    leftMax = Math.max(height[i], leftMax);\n    left[i] = leftMax;\n  }\n\n  let right = [];\n  let rightMax = 0;\n\n  for (let i = height.length - 1; i >= 0; i--) {\n    rightMax = Math.max(height[i], rightMax);\n    right[i] = rightMax;\n  }\n\n  let totalVolume = 0;\n  for (let i = 1; i < height.length - 1; i++) {\n    totalVolume += Math.min(left[i], right[i]) - height[i];\n  }\n\n  return totalVolume;\n};\n",
              "tags": ["Amazon"]
            },
            {
              "path": "resources/Beginner/Arrays/vaild_paranthesis.js",
              "name": "vaild_paranthesis.js",
              "docs": "\n\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\n\n\nExample 1:\n\nInput: s = \"()\"\nOutput: true\nExample 2:\n\nInput: s = \"()[]{}\"\nOutput: true\nExample 3:\n\nInput: s = \"(]\"\nOutput: false\n\n\nConstraints:\n\n1 <= s.length <= 104\ns consists of parentheses only '()[]{}'.\n\n\n\n",
              "solution": "\n\nvar isValid = function (s) {\n  let map = {\n    \")\": \"(\",\n    \"]\": \"[\",\n    \"}\": \"{\",\n  };\n  let arr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"(\" || s[i] === \"[\" || s[i] === \"{\") {\n      arr.push(s[i]);\n    } else {\n      if (arr[arr.length - 1] === map[s[i]]) {\n        arr.pop();\n      } else return false;\n    }\n  }\n  return arr.length === 0 ? true : false;\n};\n",
              "tags": ["Amazon"]
            }
          ]
        },
        {
          "path": "resources/Beginner/Strings",
          "name": "Strings",
          "children": [
            {
              "path": "resources/Beginner/Strings/longest_palindromic_substring.js",
              "name": "longest_palindromic_substring.js",
              "docs": "\n\n\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\nExample 3:\n\nInput: s = \"a\"\nOutput: \"a\"\nExample 4:\n\nInput: s = \"ac\"\nOutput: \"a\"\n \n\nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.   \n \n\n",
              "solution": "\n\nvar longestPalindrome = function (s) {\n  let maxPal = \"\";\n\n  for (let i = 0; i < s.length; i++) {\n    bubble(i, i); // odd palindrome\n    bubble(i, i + 1); // even palindrome\n  }\n\n  function bubble(left, right) {\n    while (left >= 0 && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    left++;\n    right--;\n\n    if (maxPal.length < right - left + 1) {\n      maxPal = s.slice(left, right + 1);\n    }\n  }\n  return maxPal;\n};\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Strings/reverse_srting.js",
              "name": "reverse_srting.js",
              "docs": "\n\n\n    given a string reverse it without using inbuild functions\n\n    ex:\n    let str = \"prepverse\";\n    result string \"esrevperp\"\n \n\n",
              "solution": "\n\nvar reverseString = function (s) {\n  let finalStr = \"\";\n  for (let c of s) {\n    finalStr = c + finalStr;\n  }\n\n  return finalStr;\n};\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Strings/reverse_string_2.js",
              "name": "reverse_string_2.js",
              "docs": "\n\n\nGiven a character array s, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in s will be separated by a single space.\n\nYour code must solve the problem in-place, i.e. without allocating extra space.\n\n \n\nExample 1:\n\nInput: s = [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]\nOutput: [\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]\nExample 2:\n\nInput: s = [\"a\"]\nOutput: [\"a\"]\n \n\nConstraints:\n\n1 <= s.length <= 105\ns[i] is an English letter (uppercase or lowercase), digit, or space ' '.\nThere is at least one word in s.\ns does not contain leading or trailing spaces.\nAll the words in s are guaranteed to be separated by a single space. \n\n",
              "solution": "\n\nvar reverseWords = function (s) {\n  s = s.reverse();\n  let ptr1 = 0;\n  let ptr2 = 0;\n  while (ptr1 < s.length) {\n    while (s[ptr2] != \" \" && ptr2 < s.length) ptr2 += 1;\n    rev(ptr1, ptr2 - 1);\n    ptr1 = ptr2 + 1;\n    ptr2 = ptr1;\n  }\n\n  return s;\n\n  function rev(l, r) {\n    while (l < r) {\n      let temp = s[l];\n      s[l] = s[r];\n      s[r] = temp;\n      l++;\n      r--;\n    }\n  }\n};\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Strings/valid_palindrome.js",
              "name": "valid_palindrome.js",
              "docs": "\n\n A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\n \n\nExample 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\nExample 3:\n\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome. \n\n",
              "solution": "\n\nvar isPalindrome = function (s) {\n  // let str = s.replaceAll(/[^a-zA-Z ]/g,\"\").toLowerCase().replaceAll(\" \",\"\");\n  let str = s.replaceAll(/\\W/g, \"\").toLowerCase();\n  let str2 = str.split(\"\").reverse().join(\"\");\n\n  if (str === str2) {\n    return true;\n  }\n  return false;\n};\n",
              "tags": ["Amazon", "Microsoft"]
            },
            {
              "path": "resources/Beginner/Strings/valid_parantheses.js",
              "name": "valid_parantheses.js",
              "tags": ["Amazon", "Microsoft"]
            }
          ]
        }
      ]
    },
    {
      "path": "resources/Expert",
      "name": "Expert",
      "children": [
        {
          "path": "resources/Expert/BST",
          "name": "BST",
          "children": [
            {
              "path": "resources/Expert/BST/binary_search_tree.js",
              "name": "binary_search_tree.js"
            },
            {
              "path": "resources/Expert/BST/binary_tree_level_order_traversal.js",
              "name": "binary_tree_level_order_traversal.js"
            },
            {
              "path": "resources/Expert/BST/binary_tree_max_path_sum.js",
              "name": "binary_tree_max_path_sum.js"
            },
            {
              "path": "resources/Expert/BST/construct_a_tree_from_inorder_and_preorder.js",
              "name": "construct_a_tree_from_inorder_and_preorder.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Expert/BST/count_bst_permuntations.js",
              "name": "count_bst_permuntations.js"
            },
            {
              "path": "resources/Expert/BST/diameter_of_a_tree.js",
              "name": "diameter_of_a_tree.js"
            },
            {
              "path": "resources/Expert/BST/flood_fill.js",
              "name": "flood_fill.js"
            },
            {
              "path": "resources/Expert/BST/invert_binary_tree.js",
              "name": "invert_binary_tree.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Expert/BST/level_order_traversal.js",
              "name": "level_order_traversal.js"
            },
            {
              "path": "resources/Expert/BST/lowest_common_ancestor.js",
              "name": "lowest_common_ancestor.js"
            },
            {
              "path": "resources/Expert/BST/populate_next_right_pointer_to_each_other.js",
              "name": "populate_next_right_pointer_to_each_other.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Expert/BST/symmetric_tree.js",
              "name": "symmetric_tree.js"
            },
            {
              "path": "resources/Expert/BST/word_ladder.js",
              "name": "word_ladder.js"
            },
            {
              "path": "resources/Expert/BST/word_ladder_2.js",
              "name": "word_ladder_2.js"
            },
            {
              "path": "resources/Expert/BST/zig_zag_level_order_traversal.js",
              "name": "zig_zag_level_order_traversal.js"
            }
          ]
        },
        {
          "path": "resources/Expert/Backtracking",
          "name": "Backtracking",
          "children": [
            {
              "path": "resources/Expert/Backtracking/all_subsets.js",
              "name": "all_subsets.js"
            }
          ]
        },
        {
          "path": "resources/Expert/Design",
          "name": "Design",
          "children": [
            {
              "path": "resources/Expert/Design/LRU_cache.js",
              "name": "LRU_cache.js"
            },
            {
              "path": "resources/Expert/Design/find_median_from_data_stream.js",
              "name": "find_median_from_data_stream.js"
            },
            {
              "path": "resources/Expert/Design/max_frequency_stack.js",
              "name": "max_frequency_stack.js"
            },
            {
              "path": "resources/Expert/Design/min_stack.js",
              "name": "min_stack.js"
            },
            {
              "path": "resources/Expert/Design/serialize_and_deserialize.js",
              "name": "serialize_and_deserialize.js"
            },
            {
              "path": "resources/Expert/Design/tick_tac_toe.js",
              "name": "tick_tac_toe.js"
            }
          ]
        },
        {
          "path": "resources/Expert/Dynamic Progarmming",
          "name": "Dynamic Progarmming",
          "children": [
            {
              "path": "resources/Expert/Dynamic Progarmming/all_construct.js",
              "name": "all_construct.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/best_sum.js",
              "name": "best_sum.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/can_construct.js",
              "name": "can_construct.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/can_sum.js",
              "name": "can_sum.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/count_construct.js",
              "name": "count_construct.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/fib_memo.js",
              "name": "fib_memo.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/grid_traveller.js",
              "name": "grid_traveller.js"
            },
            {
              "path": "resources/Expert/Dynamic Progarmming/how_sum.js",
              "name": "how_sum.js"
            }
          ]
        },
        {
          "path": "resources/Expert/Graph",
          "name": "Graph",
          "children": [
            {
              "path": "resources/Expert/Graph/clone_graph.js",
              "name": "clone_graph.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Expert/Graph/connected_components_count.js",
              "name": "connected_components_count.js"
            },
            {
              "path": "resources/Expert/Graph/course_schedule.js",
              "name": "course_schedule.js"
            },
            {
              "path": "resources/Expert/Graph/find_graph_is_sequential.js",
              "name": "find_graph_is_sequential.js"
            },
            {
              "path": "resources/Expert/Graph/graph_bfs.js",
              "name": "graph_bfs.js"
            },
            {
              "path": "resources/Expert/Graph/graph_dfs.js",
              "name": "graph_dfs.js"
            },
            {
              "path": "resources/Expert/Graph/hasPath.js",
              "name": "hasPath.js"
            },
            {
              "path": "resources/Expert/Graph/island_count.js",
              "name": "island_count.js"
            },
            {
              "path": "resources/Expert/Graph/largest_component.js",
              "name": "largest_component.js"
            },
            {
              "path": "resources/Expert/Graph/minIsland.js",
              "name": "minIsland.js"
            },
            {
              "path": "resources/Expert/Graph/shortest_path.js",
              "name": "shortest_path.js"
            },
            {
              "path": "resources/Expert/Graph/undirected_path.js",
              "name": "undirected_path.js"
            }
          ]
        }
      ]
    },
    {
      "path": "resources/Intermediate",
      "name": "Intermediate",
      "children": [
        {
          "path": "resources/Intermediate/LinkedList",
          "name": "LinkedList",
          "children": [
            {
              "path": "resources/Intermediate/LinkedList/add_two_numbers_1.js",
              "name": "add_two_numbers_1.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/add_two_numbers_2.js",
              "name": "add_two_numbers_2.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Intermediate/LinkedList/copy_linked_list_with_random.js",
              "name": "copy_linked_list_with_random.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/intersection_of_two_linked_list.js",
              "name": "intersection_of_two_linked_list.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Intermediate/LinkedList/merge_and_sort_all_linked_list.js",
              "name": "merge_and_sort_all_linked_list.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/merge_k_sorted_list.js",
              "name": "merge_k_sorted_list.js",
              "tags": ["Microsoft"]
            },
            {
              "path": "resources/Intermediate/LinkedList/merge_two_sorted_list.js",
              "name": "merge_two_sorted_list.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/reverse_linked_list.js",
              "name": "reverse_linked_list.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/reverse_node_of_K_group.js",
              "name": "reverse_node_of_K_group.js"
            },
            {
              "path": "resources/Intermediate/LinkedList/validate_cyclic.js",
              "name": "validate_cyclic.js",
              "tags": ["Microsoft"]
            }
          ]
        },
        {
          "path": "resources/Intermediate/Search",
          "name": "Search",
          "children": [
            {
              "path": "resources/Intermediate/Search/binary_search.js",
              "name": "binary_search.js"
            },
            {
              "path": "resources/Intermediate/Search/binary_search_recursion.js",
              "name": "binary_search_recursion.js"
            },
            {
              "path": "resources/Intermediate/Search/linear_search.js",
              "name": "linear_search.js"
            }
          ]
        },
        {
          "path": "resources/Intermediate/Sort",
          "name": "Sort",
          "children": [
            {
              "path": "resources/Intermediate/Sort/insertion_sort.js",
              "name": "insertion_sort.js"
            },
            {
              "path": "resources/Intermediate/Sort/merge_sort.js",
              "name": "merge_sort.js"
            },
            {
              "path": "resources/Intermediate/Sort/quick_sort.js",
              "name": "quick_sort.js"
            },
            {
              "path": "resources/Intermediate/Sort/selection_sort.js",
              "name": "selection_sort.js"
            }
          ]
        }
      ]
    },
    {
      "path": "resources/Others",
      "name": "Others",
      "children": [
        {
          "path": "resources/Others/Javascript",
          "name": "Javascript",
          "children": [
            {
              "path": "resources/Others/Javascript/async.js",
              "name": "async.js"
            },
            {
              "path": "resources/Others/Javascript/build_json_from_array.js",
              "name": "build_json_from_array.js"
            },
            {
              "path": "resources/Others/Javascript/build_json_from_element.js",
              "name": "build_json_from_element.js"
            },
            {
              "path": "resources/Others/Javascript/build_pllyfills.js",
              "name": "build_pllyfills.js"
            },
            {
              "path": "resources/Others/Javascript/build_tree.js",
              "name": "build_tree.js"
            },
            {
              "path": "resources/Others/Javascript/create_pipe.js",
              "name": "create_pipe.js"
            },
            {
              "path": "resources/Others/Javascript/currying.js",
              "name": "currying.js"
            },
            {
              "path": "resources/Others/Javascript/debounce.js",
              "name": "debounce.js"
            },
            {
              "path": "resources/Others/Javascript/decode_message.js",
              "name": "decode_message.js"
            },
            {
              "path": "resources/Others/Javascript/deep_clone.js",
              "name": "deep_clone.js"
            },
            {
              "path": "resources/Others/Javascript/flat.js",
              "name": "flat.js"
            },
            {
              "path": "resources/Others/Javascript/json_path.js",
              "name": "json_path.js"
            },
            {
              "path": "resources/Others/Javascript/memo.js",
              "name": "memo.js",
              "tags": ["Walmart"]
            },
            {
              "path": "resources/Others/Javascript/object_filter.js",
              "name": "object_filter.js"
            },
            {
              "path": "resources/Others/Javascript/reduced_string.js",
              "name": "reduced_string.js"
            },
            {
              "path": "resources/Others/Javascript/set_time_out.js",
              "name": "set_time_out.js",
              "tags": ["Walmart"]
            },
            {
              "path": "resources/Others/Javascript/simplify_path.js",
              "name": "simplify_path.js"
            },
            {
              "path": "resources/Others/Javascript/throttle.js",
              "name": "throttle.js"
            }
          ]
        }
      ]
    }
  ]
}
